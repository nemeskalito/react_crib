import {
	useState,
	counter,
	wrong,
	correctly,
	setCount,
	counterHandle,
	handleIncrement,
	objectState,
	arrayState,
	example1,
	example2,
	example3,
	example4,
	parentComp,
	userProfile,
} from './info'

export const State = () => {
	return (
		<>
			<h1>State</h1>
			<div className='impoBlock'>
				<h3>1. Что такое state?</h3>
				<p>
					State (состояние) в React — это место, где компонент хранит свои
					динамические данные. Это как записная книжка, которую компонент
					использует для хранения текущего состояния и его изменения.
				</p>
				<h2>Чем отличается state от props?</h2>
				<ul>
					<li>
						- Props передаются компоненту "снаружи", от родителя и неизменные.
					</li>
					<li>- State управляется "внутри" компонента и изменяется.</li>
				</ul>
				<span>
					Пример аналогии: Props — это текст в книге, который ты читаешь, а
					state — это твои личные заметки на полях.
				</span>
			</div>
			<div className='impoBlock'>
				<h3>2. Создание и использование state</h3>
				<h2>
					Hook <i>useState</i>
				</h2>
				<p>
					В функциональных компонентах для работы с state используется хук
					<i> useState</i>.
				</p>
				<span>Он возвращает массив из двух элементов:</span>
				<ul>
					<li>
						<i>- state</i> :текущее значение состояния
					</li>
					<li>
						<i>- setState</i> :функцию для его обновления.
					</li>
				</ul>
				<span>
					а принимает <i>initialState</i>: начальное значение состояния. Может
					быть примитивным типом данных, объектом или функцией.
				</span>
				<pre>
					<code>{useState}</code>
				</pre>
				<pre>
					<code>{counter}</code>
				</pre>
				<span>В этом примере:</span>
				<ul>
					<li>
						- <i>useState(0)</i> устанавливает начальное значение счётчика.
					</li>
					<li>
						- <i>setCount</i> обновляет значение.
					</li>
				</ul>
				<span>
					При вызове функции обновления, React перерисует компонент с новым
					значением состояния.
				</span>
			</div>
			<div className='impoBlock'>
				<h3>3. Изменение state</h3>
				<p>State должен быть неизменяемым напрямую. </p>
				<span>
					Если ты попытаешься изменить его напрямую, React не поймёт, что нужно
					обновить интерфейс:
				</span>
				<pre>
					<code>{wrong}</code>
				</pre>
				<span>
					Вместо этого используй setState, чтобы сообщить React об изменении:
				</span>
				<pre>
					<code>{correctly}</code>
				</pre>
				<h2>setState — асинхронный</h2>
				<p>
					Обновление state происходит асинхронно. Если нужно обновить состояние
					на основе его текущего значения, используй функцию:
				</p>
				<pre>
					<code>{setCount}</code>
				</pre>
				<span>
            <i>
              Этот подход гарантирует, что изменения будут выполнены корректно.
            </i>
          </span>

				<h2>Обрати внимание ещё раз — это важно!</h2>
				<span>Функция-setter (например setState) - асинхронная операция! </span>
				<span>
					<i>
						Когда мы вызываем setState, React не обновляет состояние и не
						рендерит компонент немедленно. Вместо этого он помещает обновление в
						очередь. После этого React применяет все обновления состояния за
						один раз перед следующим рендером компонента.
					</i>
				</span>
				<h2>Пример асинхронного поведения</h2>
				<p>
					Рассмотрим пример, где мы попытаемся обновить состояние несколько раз
					подряд и посмотрим, как React объединяет эти обновления:
				</p>
				<pre>
					<code>{counterHandle}</code>
				</pre>
				<p>
					В этом примере, когда нажимаем кнопку, handleIncrement вызывается, и
					мы трижды вызываем setCount(count + 1). Интуитивно может показаться,
					что count должен увеличиться на 3, но это не так
					<i>
						Все три вызова setCount объединяются в одно обновление, и в итоге
						count увеличится только на 1.
					</i>
				</p>
				<span>
					Чтобы корректно обновить состояние на основе предыдущего значения,
					следует использовать функциональный сеттер:
				</span>
				<pre>
					<code>{handleIncrement}</code>
				</pre>
				<span>
					В этом случае prevCount будет обновлено каждый раз, и состояние count
					увеличится на 3, как ожидается.
				</span>
				<h2>Важность асинхронного поведения</h2>
				<span>Асинхронное поведение сеттеров в React позволяет:</span>
				<ul>
					<li>
						- Объединять несколько обновлений состояния в одно, что уменьшает
						количество рендеров и улучшает производительность.
					</li>
					<li>
						- !!!Гарантировать!!!, что компоненты рендерятся с наиболее
						актуальным состоянием.
					</li>
				</ul>
			</div>
			<div className='impoBlock'>
				<h3>4. Работа с объектами и массивами в state</h3>
				<h2>Обновление объектов</h2>
				<p>
					Если state содержит объект, обновляй его с помощью оператора spread
					(...):
				</p>
				<pre>
					<code>{objectState}</code>
				</pre>
				<h2>Обновление массивов</h2>
				<span>
					Для обновления массивов тоже используй методы, создающие новый массив:
				</span>
				<pre>
					<code>{arrayState}</code>
				</pre>
			</div>
			<div className='impoBlock'>
				<h3>5. Состояние и перерисовка</h3>
				<h2>Как state влияет на перерисовку?</h2>
				<p>
					Когда state обновляется, React автоматически перерисовывает компонент.
					Это делает работу с интерфейсом более удобной, но может привести к
					лишним обновлениям, если state изменяется слишком часто.
				</p>
				<h2>Оптимизация обновлений</h2>
				<ul>
					<li>- Храни минимально необходимое состояние.</li>
					<li>
						- Используй мемоизацию (React.memo, useMemo, useCallback) для
						оптимизации.
					</li>
				</ul>
			</div>
			<div className='impoBlock'>
				<h3>6. Примеры использования state</h3>
				<h2>Cчетчик</h2>
				<pre>
					<code>{example1}</code>
				</pre>
				<p>
					Компонент будет отображать текущее значение счетчика, а при нажатии на
					кнопку счетчик будет увеличиваться.
				</p>
				<h2>Управление отображением элементов</h2>
				<pre>
					<code>{example2}</code>
				</pre>
				<p>
					В этом примере по клику на кнопку вызывается функция handleClick,
					которая вызывается при клике на кнопку. Она вызывает функцию
					setShowText которая изменяет текущий state на противоположный, что и
					отвечает за “показать” или “скрыть” текст.
				</p>
				<h2>Управление input-ом</h2>
				<pre>
					<code>{example3}</code>
				</pre>
				<p>
					В этом примере мы создали state с начальным значением пустой строки и
					присвоили его переменной name. В инпуте по событию onChange мы
					вызываем эту функцию, и меняет пустую строку, на те данные которые
					ввел пользователь. Да да, event.target.value это те данные, которые
					вводит пользователь. И затем мы обратно в input в атрибуте value
					присваиваем значение state.
				</p>
				<h2>Управление стилями</h2>
				<pre>
					<code>{example4}</code>
				</pre>
				<p>
					В этом примере мы создали state с начальным значением 'red' и
					присвоили его переменной color. Мы также создали функцию handleClick,
					которая вызывается при клике на кнопку, и использует функцию setColor
					для изменения значения state. Мы используем объект style для установки
					цвета текста, который зависит от значения state.
				</p>
				<i>State можно передавать в дочерние компоненты при помощи props.</i>
				<pre>
					<code>{parentComp}</code>
				</pre>
				<p>
					В данном примере состояние счетчика хранится в родительском компоненте
					ParentComponent, а значение состояния передается в дочерний компонент
					ChildComponent через пропсы.
				</p>
				<h2>state с объектом</h2>
				<p>
					Давай рассмотрим пример использования объекта в качестве состояния. Мы
					создадим компонент, который управляет профилем пользователя с именем,
					возрастом и электронной почтой.{' '}
				</p>
				<p>
					Важно помнить, что при обновлении объекта в состоянии нужно создавать
					новый объект вместо изменения существующего, чтобы соблюсти принцип
					неизменяемости.
				</p>
				<pre>
					<code>{userProfile}</code>
				</pre>
				<span>В этом примере:</span>
				<ul>
					<li>
						- Мы инициализируем стейт user как объект с тремя свойствами: name,
						age и email.
					</li>
					<li>
						Используем функцию handleChange, чтобы обновить состояние при
						изменении любого из полей ввода. Эта функция:
						<ul>
							<li>- Извлекает name и value из события.</li>
							<li>
								- Создает новый объект состояния, копируя существующие свойства
								с помощью оператора spread (...prevUser) и обновляя измененное
								свойство.
							</li>
						</ul>
					</li>
					<li>
						- Каждый элемент ввода (input) имеет атрибут name, который
						соответствует ключу объекта состояния. Это позволяет использовать
						один обработчик для всех полей ввода.
					</li>
				</ul>
			</div>
		</>
	)
}
